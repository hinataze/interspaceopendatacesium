<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cesium Parcels (ion GeoJSON)</title>

    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />

    <style>
      html,
      body,
      #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <div id="cesiumContainer"></div>

    <script>
      // Cesium ion API endpoint
      Cesium.Ion.defaultServer = "https://api.cesium.com/";

      // ðŸ”’ Put your token here
      Cesium.Ion.defaultAccessToken = "PASTE_YOUR_TOKEN_HERE";

      const viewer = new Cesium.Viewer("cesiumContainer", {
        terrain: Cesium.Terrain.fromWorldTerrain(),
        animation: false,
        timeline: false,
        baseLayerPicker: false,
        geocoder: false,
        sceneModePicker: true,
        navigationHelpButton: false,
        infoBox: true,
        selectionIndicator: true,
      });

      (async () => {
        try {
          const assetId = 1446854; // Parcels GeoJSON

          const resource = await Cesium.IonResource.fromAssetId(assetId);
          const dataSource = await Cesium.GeoJsonDataSource.load(resource, {
            clampToGround: true,
          });

          await viewer.dataSources.add(dataSource);

          // Make the GeoJSON visible
          const ents = dataSource.entities.values;
          for (const e of ents) {
            if (e.polygon) {
              e.polygon.material = Cesium.Color.YELLOW.withAlpha(0.35);
              e.polygon.outline = true;
              e.polygon.outlineColor = Cesium.Color.BLACK;
              e.polygon.outlineWidth = 2;
            }
            if (e.polyline) {
              e.polyline.width = 3;
              e.polyline.material = Cesium.Color.YELLOW;
            }
            if (e.point) {
              e.point.pixelSize = 7;
              e.point.color = Cesium.Color.YELLOW;
            }
          }

          // Wait a moment so Cesium computes bounds
          await new Promise((r) => setTimeout(r, 300));

          // Compute dataset rectangle and fly to it
          const time = Cesium.JulianDate.now();
          let rect = null;

          for (const e of ents) {
            if (e.polygon && e.polygon.hierarchy) {
              const h = e.polygon.hierarchy.getValue(time);
              if (h?.positions?.length) {
                const r2 = Cesium.Rectangle.fromCartesianArray(h.positions);
                rect = rect ? Cesium.Rectangle.union(rect, r2, rect) : r2;
              }
            }
          }

          // Add padding
          const padDeg = 0.001; // ~111m latitude
          const pad = Cesium.Math.toRadians(padDeg);

          if (rect) {
            const padded = new Cesium.Rectangle(
              rect.west - pad,
              rect.south - pad,
              rect.east + pad,
              rect.north + pad
            );

            viewer.camera.flyTo({
              destination: padded,
              duration: 0.0,
            });

            // Home button returns to dataset
            viewer.homeButton.viewModel.command.beforeExecute.addEventListener((e) => {
              e.cancel = true;
              viewer.camera.flyTo({ destination: padded, duration: 0.0 });
            });
          } else {
            // Fallback
            await viewer.flyTo(dataSource, { duration: 0.0 });
            viewer.homeButton.viewModel.command.beforeExecute.addEventListener((e) => {
              e.cancel = true;
              viewer.flyTo(dataSource, { duration: 0.0 });
            });
          }

          console.log("Loaded entities:", ents.length);
        } catch (err) {
          console.error(err);
          document.body.innerHTML =
            "<pre style='white-space:pre-wrap;font-size:14px;padding:20px'>" +
            (err?.stack || err?.message || err) +
            "</pre>";
        }
      })();
    </script>
  </body>
</html>
